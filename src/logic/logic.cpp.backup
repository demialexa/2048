#include "logic/logic.h"
#include "display/display.h"

#include <cstdint>
#include <vector>
#include <cstdlib>
#include <iostream>
#include <ctime>

Logic::Logic(uint32_t length)
    : length_(length)
    , matrix_(length, std::vector<Tiles>(length, Tiles::kNoTile))
    , free_(length_ * length_)
    , game_over_(false)
    , success_(false) {
  srand(time(NULL));
    NewTile();
    NewTile();
}

static Tiles NextTile(Tiles tile) {
  if (tile == Tiles::kTile_2048)
    throw std::runtime_error("next tile for 2048 is undefined");
  if (tile == Tiles::kNoTile)
    return Tiles::kNoTile;
  uint32_t tile_number = static_cast<uint32_t>(tile);
  return static_cast<Tiles>(tile_number + 1);
}

void Logic::NewTile() {
  if (!free_)
    game_over_ = true;
  uint32_t number = rand() % free_, count = -1;
  for (uint32_t i = 0; i < length_; i++)
    for (uint32_t j = 0; j < length_; j++) {
      if (matrix_[i][j] == Tiles::kNoTile)
        count++;
      if (count == number) {
        matrix_[i][j] = Tiles::kTile_64;
        free_--;
        return;
      }
    }
}

void Logic::MergeLeft(std::vector<Tiles>& row) {
  for (uint32_t from = 1, to = 0; from < length_; from++) {
    if (row[from] == Tiles::kNoTile)
      continue;
    if (row[to] == Tiles::kNoTile || row[to] != row[from]) {
      to = from;
      continue;
    }
    row[to] = NextTile(row[to]);
    if (row[to] == Tiles::kTile_2048)
      game_over_ = success_ = true;
    row[from] = Tiles::kNoTile;
    free_++;
    to = ++from;
  }
}

void Logic::ShiftLeft(std::vector<Tiles>& row) {
  uint32_t from = 1, to = 0;
  while (from < length_) {
    if (row[from] != Tiles::kNoTile) {
      if (row[to] == Tiles::kNoTile) {
        row[to] = row[from];
        row[from] = Tiles::kNoTile;
      }
      if (to < from - 1) {
        to++;
        continue;
      }
    }
    from++;
  }
}

void Logic::MoveLeft() {
  for (auto& row : matrix_) {
    MergeLeft(row);
    ShiftLeft(row);
  }
}

void Logic::MergeRight(std::vector<Tiles>& row) {
  for (int32_t from = length_ - 2, to = length_ - 1; from >= 0; from--) {
    if (row[from] == Tiles::kNoTile)
      continue;
    if (row[to] == Tiles::kNoTile || row[to] != row[from]) {
      to = from;
      continue;
    }
    row[to] = NextTile(row[to]);
    if (row[to] == Tiles::kTile_2048)
      game_over_ = success_ = true;
    row[from] = Tiles::kNoTile;
    free_++;
    to = --from;
  }
}

void Logic::ShiftRight(std::vector<Tiles>& row) {
  int32_t from = length_ - 2, to = length_ - 1;
  while (from >= 0) {
    if (row[from] != Tiles::kNoTile) {
      if (row[to] == Tiles::kNoTile) {
        row[to] = row[from];
        row[from] = Tiles::kNoTile;
      }
      if (to > from + 1) {
        to--;
        continue;
      }
    }
    from--;
  }
}

void Logic::MoveRight() {
  for (auto& row : matrix_) {
    MergeRight(row);
    ShiftRight(row);
  }
}

void Logic::Transpose() {
  for (uint32_t i = 0; i < length_; i++) {
    for (uint32_t j = i + 1; j < length_; j++) {
      Tiles tmp = matrix_[i][j];
      matrix_[i][j] = matrix_[j][i];
      matrix_[j][i] = tmp;
    }
  }
}

void Logic::MoveUp() {
  Transpose();
  MoveLeft();
  Transpose();
}

void Logic::MoveDown() {
  Transpose();
  MoveRight();
  Transpose();
}

#if 0
void Logic::MoveUp() {
  for (uint32_t j = 0; j < length_; j++)
    for (uint32_t i = 1; i < length_; i++) {
      if (matrix_[i - 1][j] != Tiles::kNoTile ||
          matrix_[i][j] == Tiles::kNoTile)
        continue;
      uint32_t k;
      for (k = i - 1; k > 0; k--)
        if (matrix_[k][j] != Tiles::kNoTile)
          break;
      matrix_[k + 1][j] = matrix_[i][j];
      matrix_[i][j] = Tiles::kNoTile;
    }
}

void Logic::MoveDown() {
  for (uint32_t j = 0; j < length_; j++)
    for (uint32_t i = length_ - 1; i > 0; i--) {
      if (matrix_[i][j] != Tiles::kNoTile ||
          matrix_[i - 1][j] == Tiles::kNoTile)
        continue;
      uint32_t k;
      for (k = i; k < length_; k++)
        if (matrix_[k][j] != Tiles::kNoTile)
          break;
      matrix_[k - 1][j] = matrix_[i - 1][j];
      matrix_[i - 1][j] = Tiles::kNoTile;
    }
}
#endif
